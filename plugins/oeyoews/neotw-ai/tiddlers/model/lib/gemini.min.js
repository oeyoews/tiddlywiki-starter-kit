"use strict";
const proxy = $tw.wiki.getTiddler('$:/plugins/oeyoews/neotw-ai/config').fields.proxy
/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const POSSIBLE_ROLES=["user","model","function"];exports.HarmCategory=void 0;(function(HarmCategory){HarmCategory["HARM_CATEGORY_UNSPECIFIED"]="HARM_CATEGORY_UNSPECIFIED";HarmCategory["HARM_CATEGORY_HATE_SPEECH"]="HARM_CATEGORY_HATE_SPEECH";HarmCategory["HARM_CATEGORY_SEXUALLY_EXPLICIT"]="HARM_CATEGORY_SEXUALLY_EXPLICIT";HarmCategory["HARM_CATEGORY_HARASSMENT"]="HARM_CATEGORY_HARASSMENT";HarmCategory["HARM_CATEGORY_DANGEROUS_CONTENT"]="HARM_CATEGORY_DANGEROUS_CONTENT"})(exports.HarmCategory||(exports.HarmCategory={}));exports.HarmBlockThreshold=void 0;(function(HarmBlockThreshold){HarmBlockThreshold["HARM_BLOCK_THRESHOLD_UNSPECIFIED"]="HARM_BLOCK_THRESHOLD_UNSPECIFIED";HarmBlockThreshold["BLOCK_LOW_AND_ABOVE"]="BLOCK_LOW_AND_ABOVE";HarmBlockThreshold["BLOCK_MEDIUM_AND_ABOVE"]="BLOCK_MEDIUM_AND_ABOVE";HarmBlockThreshold["BLOCK_ONLY_HIGH"]="BLOCK_ONLY_HIGH";HarmBlockThreshold["BLOCK_NONE"]="BLOCK_NONE"})(exports.HarmBlockThreshold||(exports.HarmBlockThreshold={}));exports.HarmProbability=void 0;(function(HarmProbability){HarmProbability["HARM_PROBABILITY_UNSPECIFIED"]="HARM_PROBABILITY_UNSPECIFIED";HarmProbability["NEGLIGIBLE"]="NEGLIGIBLE";HarmProbability["LOW"]="LOW";HarmProbability["MEDIUM"]="MEDIUM";HarmProbability["HIGH"]="HIGH"})(exports.HarmProbability||(exports.HarmProbability={}));exports.BlockReason=void 0;(function(BlockReason){BlockReason["BLOCKED_REASON_UNSPECIFIED"]="BLOCKED_REASON_UNSPECIFIED";BlockReason["SAFETY"]="SAFETY";BlockReason["OTHER"]="OTHER"})(exports.BlockReason||(exports.BlockReason={}));exports.FinishReason=void 0;(function(FinishReason){FinishReason["FINISH_REASON_UNSPECIFIED"]="FINISH_REASON_UNSPECIFIED";FinishReason["STOP"]="STOP";FinishReason["MAX_TOKENS"]="MAX_TOKENS";FinishReason["SAFETY"]="SAFETY";FinishReason["RECITATION"]="RECITATION";FinishReason["OTHER"]="OTHER"})(exports.FinishReason||(exports.FinishReason={}));exports.TaskType=void 0;(function(TaskType){TaskType["TASK_TYPE_UNSPECIFIED"]="TASK_TYPE_UNSPECIFIED";TaskType["RETRIEVAL_QUERY"]="RETRIEVAL_QUERY";TaskType["RETRIEVAL_DOCUMENT"]="RETRIEVAL_DOCUMENT";TaskType["SEMANTIC_SIMILARITY"]="SEMANTIC_SIMILARITY";TaskType["CLASSIFICATION"]="CLASSIFICATION";TaskType["CLUSTERING"]="CLUSTERING"})(exports.TaskType||(exports.TaskType={}));
/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */exports.FunctionDeclarationSchemaType=void 0;(function(FunctionDeclarationSchemaType){FunctionDeclarationSchemaType["STRING"]="STRING";FunctionDeclarationSchemaType["NUMBER"]="NUMBER";FunctionDeclarationSchemaType["INTEGER"]="INTEGER";FunctionDeclarationSchemaType["BOOLEAN"]="BOOLEAN";FunctionDeclarationSchemaType["ARRAY"]="ARRAY";FunctionDeclarationSchemaType["OBJECT"]="OBJECT"})(exports.FunctionDeclarationSchemaType||(exports.FunctionDeclarationSchemaType={}));
/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class GoogleGenerativeAIError extends Error{constructor(message){super(`[GoogleGenerativeAI Error]: ${message}`)}}class GoogleGenerativeAIResponseError extends GoogleGenerativeAIError{constructor(message,response){super(message);this.response=response}}
/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const BASE_URL = proxy || "https://generativelanguage.googleapis.com";
const DEFAULT_API_VERSION = "v1"; const PACKAGE_VERSION = "0.3.1"; const PACKAGE_LOG_HEADER = "genai-js"; var Task; (function (Task) { Task["GENERATE_CONTENT"] = "generateContent"; Task["STREAM_GENERATE_CONTENT"] = "streamGenerateContent"; Task["COUNT_TOKENS"] = "countTokens"; Task["EMBED_CONTENT"] = "embedContent"; Task["BATCH_EMBED_CONTENTS"] = "batchEmbedContents" })(Task || (Task = {})); class RequestUrl{ constructor(model, task, apiKey, stream, requestOptions) { this.model = model; this.task = task; this.apiKey = apiKey; this.stream = stream; this.requestOptions = requestOptions } toString() { var _a; const apiVersion = ((_a = this.requestOptions) === null || _a === void 0 ? void 0 : _a.apiVersion) || DEFAULT_API_VERSION; let url = `${BASE_URL}/${apiVersion}/${this.model}:${this.task}`; if (this.stream) { url += "?alt=sse" } return url } } function getClientHeaders() { return `${PACKAGE_LOG_HEADER}/${PACKAGE_VERSION}` } async function makeRequest(url, body, requestOptions) { let response; try { response = await fetch(url.toString(), Object.assign(Object.assign({}, buildFetchOptions(requestOptions)), { method: "POST", headers: { "Content-Type": "application/json", "x-goog-api-client": getClientHeaders(), "x-goog-api-key": url.apiKey }, body: body })); if (!response.ok) { let message = ""; try { const json = await response.json(); message = json.error.message; if (json.error.details) { message += ` ${JSON.stringify(json.error.details)}` } } catch (e) { } throw new Error(`[${response.status} ${response.statusText}] ${message}`) } } catch (e) { const err = new GoogleGenerativeAIError(`Error fetching from ${url.toString()}: ${e.message}`); err.stack = e.stack; throw err } return response } function buildFetchOptions(requestOptions) { const fetchOptions = {}; if ((requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeout) >= 0) { const abortController = new AbortController; const signal = abortController.signal; setTimeout((() => abortController.abort()), requestOptions.timeout); fetchOptions.signal = signal } return fetchOptions }
/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function addHelpers(response){response.text=()=>{if(response.candidates&&response.candidates.length>0){if(response.candidates.length>1){console.warn(`This response had ${response.candidates.length} `+`candidates. Returning text from the first candidate only. `+`Access response.candidates directly to use the other candidates.`)}if(hadBadFinishReason(response.candidates[0])){throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`,response)}return getText(response)}else if(response.promptFeedback){throw new GoogleGenerativeAIResponseError(`Text not available. ${formatBlockErrorMessage(response)}`,response)}return""};response.functionCall=()=>{if(response.candidates&&response.candidates.length>0){if(response.candidates.length>1){console.warn(`This response had ${response.candidates.length} `+`candidates. Returning function call from the first candidate only. `+`Access response.candidates directly to use the other candidates.`)}if(hadBadFinishReason(response.candidates[0])){throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`,response)}return getFunctionCall(response)}else if(response.promptFeedback){throw new GoogleGenerativeAIResponseError(`Function call not available. ${formatBlockErrorMessage(response)}`,response)}return undefined};return response}function getText(response){var _a,_b,_c,_d;if((_d=(_c=(_b=(_a=response.candidates)===null||_a===void 0?void 0:_a[0].content)===null||_b===void 0?void 0:_b.parts)===null||_c===void 0?void 0:_c[0])===null||_d===void 0?void 0:_d.text){return response.candidates[0].content.parts.map((({text:text})=>text)).join("")}else{return""}}function getFunctionCall(response){var _a,_b,_c,_d;return(_d=(_c=(_b=(_a=response.candidates)===null||_a===void 0?void 0:_a[0].content)===null||_b===void 0?void 0:_b.parts)===null||_c===void 0?void 0:_c[0])===null||_d===void 0?void 0:_d.functionCall}const badFinishReasons=[exports.FinishReason.RECITATION,exports.FinishReason.SAFETY];function hadBadFinishReason(candidate){return!!candidate.finishReason&&badFinishReasons.includes(candidate.finishReason)}function formatBlockErrorMessage(response){var _a,_b,_c;let message="";if((!response.candidates||response.candidates.length===0)&&response.promptFeedback){message+="Response was blocked";if((_a=response.promptFeedback)===null||_a===void 0?void 0:_a.blockReason){message+=` due to ${response.promptFeedback.blockReason}`}if((_b=response.promptFeedback)===null||_b===void 0?void 0:_b.blockReasonMessage){message+=`: ${response.promptFeedback.blockReasonMessage}`}}else if((_c=response.candidates)===null||_c===void 0?void 0:_c[0]){const firstCandidate=response.candidates[0];if(hadBadFinishReason(firstCandidate)){message+=`Candidate was blocked due to ${firstCandidate.finishReason}`;if(firstCandidate.finishMessage){message+=`: ${firstCandidate.finishMessage}`}}}return message}function __await(v){return this instanceof __await?(this.v=v,this):new __await(v)}function __asyncGenerator(thisArg,_arguments,generator){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var g=generator.apply(thisArg,_arguments||[]),i,q=[];return i={},verb("next"),verb("throw"),verb("return"),i[Symbol.asyncIterator]=function(){return this},i;function verb(n){if(g[n])i[n]=function(v){return new Promise((function(a,b){q.push([n,v,a,b])>1||resume(n,v)}))}}function resume(n,v){try{step(g[n](v))}catch(e){settle(q[0][3],e)}}function step(r){r.value instanceof __await?Promise.resolve(r.value.v).then(fulfill,reject):settle(q[0][2],r)}function fulfill(value){resume("next",value)}function reject(value){resume("throw",value)}function settle(f,v){if(f(v),q.shift(),q.length)resume(q[0][0],q[0][1])}}typeof SuppressedError==="function"?SuppressedError:function(error,suppressed,message){var e=new Error(message);return e.name="SuppressedError",e.error=error,e.suppressed=suppressed,e};
/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const responseLineRE=/^data\: (.*)(?:\n\n|\r\r|\r\n\r\n)/;function processStream(response){const inputStream=response.body.pipeThrough(new TextDecoderStream("utf8",{fatal:true}));const responseStream=getResponseStream(inputStream);const[stream1,stream2]=responseStream.tee();return{stream:generateResponseSequence(stream1),response:getResponsePromise(stream2)}}async function getResponsePromise(stream){const allResponses=[];const reader=stream.getReader();while(true){const{done:done,value:value}=await reader.read();if(done){return addHelpers(aggregateResponses(allResponses))}allResponses.push(value)}}function generateResponseSequence(stream){return __asyncGenerator(this,arguments,(function*generateResponseSequence_1(){const reader=stream.getReader();while(true){const{value:value,done:done}=yield __await(reader.read());if(done){break}yield yield __await(addHelpers(value))}}))}function getResponseStream(inputStream){const reader=inputStream.getReader();const stream=new ReadableStream({start(controller){let currentText="";return pump();function pump(){return reader.read().then((({value:value,done:done})=>{if(done){if(currentText.trim()){controller.error(new GoogleGenerativeAIError("Failed to parse stream"));return}controller.close();return}currentText+=value;let match=currentText.match(responseLineRE);let parsedResponse;while(match){try{parsedResponse=JSON.parse(match[1])}catch(e){controller.error(new GoogleGenerativeAIError(`Error parsing JSON response: "${match[1]}"`));return}controller.enqueue(parsedResponse);currentText=currentText.substring(match[0].length);match=currentText.match(responseLineRE)}return pump()}))}}});return stream}function aggregateResponses(responses){const lastResponse=responses[responses.length-1];const aggregatedResponse={promptFeedback:lastResponse===null||lastResponse===void 0?void 0:lastResponse.promptFeedback};for(const response of responses){if(response.candidates){for(const candidate of response.candidates){const i=candidate.index;if(!aggregatedResponse.candidates){aggregatedResponse.candidates=[]}if(!aggregatedResponse.candidates[i]){aggregatedResponse.candidates[i]={index:candidate.index}}aggregatedResponse.candidates[i].citationMetadata=candidate.citationMetadata;aggregatedResponse.candidates[i].finishReason=candidate.finishReason;aggregatedResponse.candidates[i].finishMessage=candidate.finishMessage;aggregatedResponse.candidates[i].safetyRatings=candidate.safetyRatings;if(candidate.content&&candidate.content.parts){if(!aggregatedResponse.candidates[i].content){aggregatedResponse.candidates[i].content={role:candidate.content.role||"user",parts:[]}}const newPart={};for(const part of candidate.content.parts){if(part.text){newPart.text=part.text}if(part.functionCall){newPart.functionCall=part.functionCall}if(Object.keys(newPart).length===0){newPart.text=""}aggregatedResponse.candidates[i].content.parts.push(newPart)}}}}}return aggregatedResponse}
/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function generateContentStream(apiKey,model,params,requestOptions){const url=new RequestUrl(model,Task.STREAM_GENERATE_CONTENT,apiKey,true,requestOptions);const response=await makeRequest(url,JSON.stringify(params),requestOptions);return processStream(response)}async function generateContent(apiKey,model,params,requestOptions){const url=new RequestUrl(model,Task.GENERATE_CONTENT,apiKey,false,requestOptions);const response=await makeRequest(url,JSON.stringify(params),requestOptions);const responseJson=await response.json();const enhancedResponse=addHelpers(responseJson);return{response:enhancedResponse}}
/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function formatNewContent(request){let newParts=[];if(typeof request==="string"){newParts=[{text:request}]}else{for(const partOrString of request){if(typeof partOrString==="string"){newParts.push({text:partOrString})}else{newParts.push(partOrString)}}}return assignRoleToPartsAndValidateSendMessageRequest(newParts)}function assignRoleToPartsAndValidateSendMessageRequest(parts){const userContent={role:"user",parts:[]};const functionContent={role:"function",parts:[]};let hasUserContent=false;let hasFunctionContent=false;for(const part of parts){if("functionResponse"in part){functionContent.parts.push(part);hasFunctionContent=true}else{userContent.parts.push(part);hasUserContent=true}}if(hasUserContent&&hasFunctionContent){throw new GoogleGenerativeAIError("Within a single message, FunctionResponse cannot be mixed with other type of part in the request for sending chat message.")}if(!hasUserContent&&!hasFunctionContent){throw new GoogleGenerativeAIError("No content is provided for sending chat message.")}if(hasUserContent){return userContent}return functionContent}function formatGenerateContentInput(params){if(params.contents){return params}else{const content=formatNewContent(params);return{contents:[content]}}}function formatEmbedContentInput(params){if(typeof params==="string"||Array.isArray(params)){const content=formatNewContent(params);return{content:content}}return params}
/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const VALID_PART_FIELDS=["text","inlineData","functionCall","functionResponse"];const VALID_PARTS_PER_ROLE={user:["text","inlineData"],function:["functionResponse"],model:["text","functionCall"]};const VALID_PREVIOUS_CONTENT_ROLES={user:["model"],function:["model"],model:["user","function"]};function validateChatHistory(history){let prevContent;for(const currContent of history){const{role:role,parts:parts}=currContent;if(!prevContent&&role!=="user"){throw new GoogleGenerativeAIError(`First content should be with role 'user', got ${role}`)}if(!POSSIBLE_ROLES.includes(role)){throw new GoogleGenerativeAIError(`Each item should include role field. Got ${role} but valid roles are: ${JSON.stringify(POSSIBLE_ROLES)}`)}if(!Array.isArray(parts)){throw new GoogleGenerativeAIError("Content should have 'parts' property with an array of Parts")}if(parts.length===0){throw new GoogleGenerativeAIError("Each Content should have at least one part")}const countFields={text:0,inlineData:0,functionCall:0,functionResponse:0};for(const part of parts){for(const key of VALID_PART_FIELDS){if(key in part){countFields[key]+=1}}}const validParts=VALID_PARTS_PER_ROLE[role];for(const key of VALID_PART_FIELDS){if(!validParts.includes(key)&&countFields[key]>0){throw new GoogleGenerativeAIError(`Content with role '${role}' can't contain '${key}' part`)}}if(prevContent){const validPreviousContentRoles=VALID_PREVIOUS_CONTENT_ROLES[role];if(!validPreviousContentRoles.includes(prevContent.role)){throw new GoogleGenerativeAIError(`Content with role '${role}' can't follow '${prevContent.role}'. Valid previous roles: ${JSON.stringify(VALID_PREVIOUS_CONTENT_ROLES)}`)}}prevContent=currContent}}
/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const SILENT_ERROR="SILENT_ERROR";class ChatSession{constructor(apiKey,model,params,requestOptions){this.model=model;this.params=params;this.requestOptions=requestOptions;this._history=[];this._sendPromise=Promise.resolve();this._apiKey=apiKey;if(params===null||params===void 0?void 0:params.history){validateChatHistory(params.history);this._history=params.history}}async getHistory(){await this._sendPromise;return this._history}async sendMessage(request){var _a,_b,_c;await this._sendPromise;const newContent=formatNewContent(request);const generateContentRequest={safetySettings:(_a=this.params)===null||_a===void 0?void 0:_a.safetySettings,generationConfig:(_b=this.params)===null||_b===void 0?void 0:_b.generationConfig,tools:(_c=this.params)===null||_c===void 0?void 0:_c.tools,contents:[...this._history,newContent]};let finalResult;this._sendPromise=this._sendPromise.then((()=>generateContent(this._apiKey,this.model,generateContentRequest,this.requestOptions))).then((result=>{var _a;if(result.response.candidates&&result.response.candidates.length>0){this._history.push(newContent);const responseContent=Object.assign({parts:[],role:"model"},(_a=result.response.candidates)===null||_a===void 0?void 0:_a[0].content);this._history.push(responseContent)}else{const blockErrorMessage=formatBlockErrorMessage(result.response);if(blockErrorMessage){console.warn(`sendMessage() was unsuccessful. ${blockErrorMessage}. Inspect response object for details.`)}}finalResult=result}));await this._sendPromise;return finalResult}async sendMessageStream(request){var _a,_b,_c;await this._sendPromise;const newContent=formatNewContent(request);const generateContentRequest={safetySettings:(_a=this.params)===null||_a===void 0?void 0:_a.safetySettings,generationConfig:(_b=this.params)===null||_b===void 0?void 0:_b.generationConfig,tools:(_c=this.params)===null||_c===void 0?void 0:_c.tools,contents:[...this._history,newContent]};const streamPromise=generateContentStream(this._apiKey,this.model,generateContentRequest,this.requestOptions);this._sendPromise=this._sendPromise.then((()=>streamPromise)).catch((_ignored=>{throw new Error(SILENT_ERROR)})).then((streamResult=>streamResult.response)).then((response=>{if(response.candidates&&response.candidates.length>0){this._history.push(newContent);const responseContent=Object.assign({},response.candidates[0].content);if(!responseContent.role){responseContent.role="model"}this._history.push(responseContent)}else{const blockErrorMessage=formatBlockErrorMessage(response);if(blockErrorMessage){console.warn(`sendMessageStream() was unsuccessful. ${blockErrorMessage}. Inspect response object for details.`)}}})).catch((e=>{if(e.message!==SILENT_ERROR){console.error(e)}}));return streamPromise}}
/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function countTokens(apiKey,model,params,requestOptions){const url=new RequestUrl(model,Task.COUNT_TOKENS,apiKey,false,{});const response=await makeRequest(url,JSON.stringify(Object.assign(Object.assign({},params),{model:model})),requestOptions);return response.json()}
/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function embedContent(apiKey,model,params,requestOptions){const url=new RequestUrl(model,Task.EMBED_CONTENT,apiKey,false,{});const response=await makeRequest(url,JSON.stringify(params),requestOptions);return response.json()}async function batchEmbedContents(apiKey,model,params,requestOptions){const url=new RequestUrl(model,Task.BATCH_EMBED_CONTENTS,apiKey,false,{});const requestsWithModel=params.requests.map((request=>Object.assign(Object.assign({},request),{model:model})));const response=await makeRequest(url,JSON.stringify({requests:requestsWithModel}),requestOptions);return response.json()}
/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class GenerativeModel{constructor(apiKey,modelParams,requestOptions){this.apiKey=apiKey;if(modelParams.model.includes("/")){this.model=modelParams.model}else{this.model=`models/${modelParams.model}`}this.generationConfig=modelParams.generationConfig||{};this.safetySettings=modelParams.safetySettings||[];this.tools=modelParams.tools;this.requestOptions=requestOptions||{}}async generateContent(request){const formattedParams=formatGenerateContentInput(request);return generateContent(this.apiKey,this.model,Object.assign({generationConfig:this.generationConfig,safetySettings:this.safetySettings,tools:this.tools},formattedParams),this.requestOptions)}async generateContentStream(request){const formattedParams=formatGenerateContentInput(request);return generateContentStream(this.apiKey,this.model,Object.assign({generationConfig:this.generationConfig,safetySettings:this.safetySettings,tools:this.tools},formattedParams),this.requestOptions)}startChat(startChatParams){return new ChatSession(this.apiKey,this.model,Object.assign({tools:this.tools},startChatParams),this.requestOptions)}async countTokens(request){const formattedParams=formatGenerateContentInput(request);return countTokens(this.apiKey,this.model,formattedParams)}async embedContent(request){const formattedParams=formatEmbedContentInput(request);return embedContent(this.apiKey,this.model,formattedParams)}async batchEmbedContents(batchEmbedContentRequest){return batchEmbedContents(this.apiKey,this.model,batchEmbedContentRequest,this.requestOptions)}}
/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class GoogleGenerativeAI{constructor(apiKey){this.apiKey=apiKey}getGenerativeModel(modelParams,requestOptions){if(!modelParams.model){throw new GoogleGenerativeAIError(`Must provide a model name. `+`Example: genai.getGenerativeModel({ model: 'my-model-name' })`)}return new GenerativeModel(this.apiKey,modelParams,requestOptions)}}exports.ChatSession=ChatSession;exports.GenerativeModel=GenerativeModel;exports.GoogleGenerativeAI=GoogleGenerativeAI;exports.POSSIBLE_ROLES=POSSIBLE_ROLES;